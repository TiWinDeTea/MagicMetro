\documentclass[report, backcover, french, nodocumentinfo]{upmethodology-document}
\include{settings}
% For more information about UPmethodology: https://www.ctan.org/pkg/upmethodology

\begin{document}

	\upmdocumentsummary{}
	\upmdocumentauthors{}
	\upmdocumentinformedpeople{}
	\upmpublicationpage{}

	\tableofcontents{}
	\listoffigures{}

	\newpage{}
	\chapter{Présentation de Mini Metro}
		\section{Un peu d'histoire...}
			\p{}
				Mini Metro est un jeu développé par le studio indépendant Dinosaur Polo inc. Mini Métro a été présenté sous le nom de Mind The Gap à la 26ème édition du Ludum Dare qui a eu lieu le 26 avril 2013. Il est ensuite développé pour devenir un jeu complet et il est proposés aux Steam Greenlight qui permet au publique de choisir quel jeu indépendant va entrer dans le catalogue Steam de manière permanente ou temporaire. Il sort sous sa forme définitive sur Steam et GOG.com le 6 novembre 2015. Il est ensuite porté sur les plateformes mobiles Android et IOS le 18 octobre 2016.
		\section{But du jeu}
			\p{}
				Mini Metro est un jeu de gestion de métro. On doit gérer les rames de métro pour pouvoir desservir toutes les stations de métro. Ces stations se remplissent, au fur et à mesure du temps, des passagers qui souhaitent aller à une station particulière. En effet, ces stations possèdent une forme et les passagers décident d'aller à une station avec une forme spécifique. Par exemple, un passager arrive à une station triangle et souhaite aller dans une station carré. Il faut donc relier les stations par des lignes et ainsi éviter qu’une station surcharge. Si une station surcharge, la partie se termine.
			\p{}
				Le jeu propose plusieurs niveaux qui se situent chacune dans une ville réelle (New York, Sydney\ldots). Dans chacun des niveaux, on peut rencontrer de nouveaux types de train et le niveau de difficulté change.
		\section{Analyse du jeu}
			\p{}
				Au démarrage du jeu, le joueur a accès à un succinct menu qui nous permet de choisir si on veut jouer, quitter le jeu ou modifier les paramètres de jeu. Si le joueur décide de jouer, il a accès à un autre menu qui lui propose tous les niveaux disponibles et le joueur choisit un niveau. Si celui-ci décide d'entrer dans les paramètres, il aura accès au contrôle de volume et la couleur du fond (blanc ou gris foncés).
			\p{}
				A l'intérieur d'un niveau, le joueur peut tracer des lignes entre les stations. Il possède un inventaire dans lequel il y a de base 3 lignes et 2 trains. Le jeu est en temps réels ainsi tous les éléments du jeu sont fonctions du temps (l'arrivée de station, de passager...). Tous les dimanches, le joueur reçoit des bonus de façon aléatoire avec parfois un choix possibles entre deux bonus.
			\p{}
				Le joueur modifie en temps réel les lignes voir retirer une ligne (il suffit de retirer la lignes de toutes les stations). Si elle est supprimée, la ligne revient dans l'inventaire du joueur. Après modification de la ligne, si un train se situé sur la section de la ligne modifié, celui-ci continue sur l'ancienne section avant la mise à jour. Si une section de la ligne passe dans une partie de l'eau, alors cette section devient un tunnel et on a un nombre limité de tunnel.
			\p{}
				Il peut aussi ajouter ou retirer un train à une ligne. Si le train est retiré, celui-ci retourne dans l'inventaire du joueur. Le joueur peut déplacer un train, mais celui-ci reste immobile pendant 2-3 secondes et les passagers présents avant le déplacement retournent à la station d'origine.

	\chapter{Conception globale du projet}
		\section{Cas d'utilisation}\label{useCases}
			\begin{figure}[h!]
				\centering
				\includegraphics[width=\textwidth]{figures/UseCaseDiagram}
				\caption{Diagramme des cas d'utilisation}
				\label{fig:UseCaseDiagram}
			\end{figure}
			\p{Simulateur}
				MiniMetro a pour particularité d'avoir un fonctionnement proche d'un simulateur, en effet a l'inverse d'un jeu d'échec par exemple qui attend sur l'utilisateur pour effectuer des action, MiniMetro lui a un fonctionnement en temps réel indépendant de l'utilisateur mais dépendant de l’environnement, que l'utilisateur peut modifier. En effet si l'utilisateur ne fait rien, le jeu continue mais cela mènera vite a la défaite, par conséquent l'utilisateur modifie l’environnement (trace des ligne, ajoute de wagons aux trains\ldots) pour empêcher la ``simulation'' d'aller a sa perte.
			\p{Actions de l'utilisateur}
				Les actions de l'utilisateur se répartissent en trois catégories:
				\begin{itemize}
					\item Choix (avant le début de la partie):
						\begin{itemize}
							\item De la carte
							\item Des options de jeu
						\end{itemize}
					\item Ajustement de la vitesse de jeu
					\item Déplacements d'éléments
						\begin{itemize}
							\item De la carte a l'inventaire
							\item De l'inventaire a la carte
							\item D'une position a l'autre (trains)
							\item Même modifier une ligne revient a déplacer les connexion et sous-sections de cette ligne\footnote{La représentation des lignes expliquer ultérieurement}
						\end{itemize}
				\end{itemize}
				Les actions décisives possible une fois en jeux pour l'utilisateur sont donc toutes des déplacements.
		\section{Le modèle MVC}
			\subsection{Adaptation a notre utilisation}
				\p{Choix}
					Nous avons choisit de séparer notre projet en 3 parties: modèle, vue et contrôleur (MCV) pour organiser le code et rendre chaque parie le plus indépendant des autres que possible. Ceci dans le but d'obtenir un code maintenable et facilement adaptable a une autre bibliothèque graphique par exemple puisqu'il suffirait de ré-implémenter une partie de la vue.
				\p{Modèle}
					Il possède toute la logique du jeu il décide a chaque instant de quoi faire et s'adapte en fonction de l’environnement. Environnement qu'il maintient a jour en fonction des modifications dont il est notifié.
				\p{Vue}
					Elle est composée de tout les éléments graphiques du projet et est donc directement dépendante de la bibliothèque graphique utilisé a l'implémentation. Nous utiliserons \textit{JavaFx}.
				\p{Contrôleur}
					Il s'occupe de donner un sens a la vue, transforme les actions abstraites du joueur (glisser sa souris de la position $(14,35)$ a la position $(452,128)$) en action concrète pour le modèle (tracer une ligne de la station $A$ a la station $B$). Il s’occupe aussi le l'action inverse de transformer les action du modèle (déplacer le train) en actions visuelles (déplacer la vue associée au train).
				\p{Prise en compte de JavaFx}
					Puisque notre vue est réalisée par une librairie graphique externe au projet (ici \textit{JavaFx}) nous avons décidé de fusionner le contrôleur et la vue au niveau de la répartition des packages, le package \jpackage{view} regroupant donc les classes de contrôle qui en interne utilisent les éléments de \textit{JavaFx}. On obtient donc deux packages principaux: \jpackage{modele} et \jpackage{view}.
				\p{}
					On arrive donc sur un modèle hybride entre modèle vue (MV) et modèle, vue et contrôleur (MCV) du fait que la séparation contrôleur -- vue qui n'apparait pas au niveau des package, cela étant du a l'utilisation d'une librairie graphique externe au projet. Néanmoins notre conception n'est pas dépendante de \textit{JavaFx} et une autre librairie graphique pourrait très bien être utilisée.

	\chapter{Classes et liaisons}
		\section{Modèle}
			\subsection{Problématiques}
				\p{}
					Pour faire le modèle, nous nous sommes basées sur les éléments visibles à l'écran (trains, lignes, stations\ldots voir digramme \ref{fig:ModelClassDiagram}). Un des problèmes que nous avons rencontré fut les lignes. Pour pouvoir faire des modifications sur la ligne, nous avons décidés de diviser les lignes en sections qui correspondent aux rails qui relient deux stations entre elles. Mais cette section peut être composé d'un angle dont on doit connaitre les coordonnées pour la vue, nous avons ainsi des sous-sections au nombre maximum de deux par section. De plus, ces sous-sections permettent de résoudre le problème des tunnels qui peuvent être sur une partie de la section et pas sur l'autre.
					\begin{figure}[h!]
						\centering
						\includegraphics[width=1\textwidth]{figures/ModelClassDiagram}
						\caption{Diagramme de classes: Modèle}
						\label{fig:ModelClassDiagram}
					\end{figure}
			\subsection{Lines}
				\p{Connection}
					Comme on peut le voir sur le digramme \ref{fig:ModelClassDiagram}, nous avons un package \jpackage{lines} qui contiendra toutes les classe qui décriront les lignes qu'on peut voir dans le jeu. Dans ce package, les connexions correspondent aux point qui séparent les sous-sections au sein de sections. Ces connexions peuvent être au sein d'une station ce qui permet de résoudre le problème de la connexion d'une station avec plusieurs lignes. En effet, on aura une liste de connexions de taille identique au nombre de lignes qui passera dans la station. Donc, on pourra définir une limite de 3 connexions (et donc de trois lignes) au sein d'une station.
				\p{Sous-section}
					Une sous-section est composée de 2 connections qui la délimite ainsi on connait sa longueur pour faire par la suite du path-finding pour les passagers. On retiendra avec un booléen si la sous-section est un tunnel ou pas pour pouvoir décrémenter ou non le compteur de tunnel présent dans l'inventaire et compter ceux-ci. On retiendra aussi la longueur de la sous-section.\\
					Dans la classe \jclass{Section}, on aura le booléen hasTunnel qui permettra de savoir si la section possède un tunnel ou pas, sa longueur et les connexions d'arrivée et de départ pour délimiter la section. On retiendra aussi la ligne à laquelle appartient la section.
				\p{Ligne}
					Dans la classe \jclass{Line}, on retiendra les connections au sein de celle-ci (pour avoir ainsi les stations qui la constituent). On stocke aussi les trains qui sont présents au sein de la ligne pour la limite de train par ligne. On a décidé de faire une composition pour avec les sections. En effet, si on décide de retirer une ligne, on aura plus de section, celle-ci étant détruite.
			\subsection{Train}
				Pour les trains, on a la classe \jclass{Train} et \jclass{PassengerCar} où \jclass{Train} est l'objet qui se déplace et le \jclass{PassengerCar} l'objet qui va transporter les passagers. La classe Train est composé de sa vitesse maximum qui va être associé en fonction de l'enum  \jclass{TrainType}. Cette enum permettra d'avoir différents train en fonction du niveau. Le train possédera une ligne s'il est sur la carte. Un  \jclass{Train} possède forcément au moins un  \jclass{PassengerCar} qui est l'unité qui transporte les personnes (les wagons). Nous sauvegarderons aussi sa position à un temps donné.\\
				Le  \jclass{Train} possèdera aussi son état. L'état du train est une interface nommée \jinterface{TrainState} qui sera implémenté par \jinterface{MovingState} et par \jinterface{AtStationState}. Ainsi, quand on sera dans une station, l'état du train sera AtStationState et quand ils se déplacera sur la ligne, son état sera une  \jclass{MovingState}. Dans \jinterface{AtStationState}, le \jclass{Train} déposera les passagers qu'il transporte et qui veulent aller à la station présente, et prendra les passagers de la station en fonction de sa capacité. Dans \jinterface{MovingState}, le \jclass{Train} se déplacera en fonction de la ligne où il est affecté. Ce choix a été fait pour qu'on appelle la fonction live dans la boucle de jeu sans se soucier de l'endroit où est le train.
			\subsection{Station}
				La classe \jclass{Station} va contenir les passagers qui veulent aller à une autre station, sa capacité maximum, les connections qu'elles possèdent pour le croisement de lignes et son type qui est ici représenté sous la forme d'un enum appelé \jclass{StationType}.
			\subsection{Réunificaiton avec le GameManager}
				C'est différentes classes vont être manipulé par un objet appelé \jclass{GameManager}. Celui-ci va gérer le jeu et posséder la boucle de jeu.
				\subsubsection{la boucle de jeu}\label{gameLoop}
					La boucle de jeu est ce qui va réaliser le temps réel. Pour ce faire on va appeler celle-ci un certain nombre de fois fixe par secondes et regardera le \jclass{TimeManager} pour savoir s'il faut rafraichir ou pas. Dans cette boucle, on vérifie si on a une action à faire en consultant le MapScript. S'il y a une action à effectuer, il applique ce qui est précisé dans la MapScript (apparition d'un bonus, d'une station\ldots). Sinon, on ne fait rien et on continue. Ensuite, on applique à tous les trains présents dans la map la fonction \jfunc{live} qui permettra de mettre à jour les trains.
				\subsubsection{attribut}
					La \jclass{GameMap} va contenir tous les objets qui seront présents sur la map (station, lignes, train\ldots). C'est cet objet qui va calculer le path-finding pour chaque passager qui va apparaitre à une station donnée. Celui-ci possédant une référence sur tous les objets présents sur la map, il pourra trouver le chemin optimal pour le passager en question.
		\section{Vue}
			La vue n'a pas de encore de conception définitive mais mais sont fonctionnement global a déjà été choisit.
			\subsection{Gestion centralisée}
				Notre vue sera gérée par le \jclass{ViewManager}. Ce dernier est celui qui communique avec le modèle (communication détaillé dans les sections suivantes). C'est lui qui instancie les éléments de la vue en fonction de la skin qui lui aura été passé en paramètre de constructeur. Cette skin (dont la conception reste encore a définir) est le groupe d'objets graphiques qui sera utilisé pour représenter les éléments a l'écran, la skin de base étant celle de \textit{MiniMetro} avec des rectangles colorés pour les trains et des formes (triangle, rond, \ldots) pour les stations. Lorsque le \jclass{GameManager} demande une vue pour un train il passe en paramètre le type du train, ainsi le \jclass{ViewManager} crée une vue du type associé avec la skin qui correspond au type du train. Lorsque le train est retiré de la carte, on passe par le \jclass{ViewManager} pour retirer la vue du train de la carte et mettre a jour le compteur de train de l'inventaire. C'est donc le \jclass{ViewManager} qui instancie et gère tout les éléments de la vue.
			\subsection{Gestion déléguée}
				Une fois la référence sur la vue fournie au train ou a la station par le biais de l'interface, sa gestion est délégué au train ou station qu'elle représente. Les fonctions de l'interface permettant par exemple pour une station d'ajouter des passagers en précisant juste le type de station vers laquelle ce dernier veut aller et l'implémentation de la vue se charge de prendre le skin associé pour ajouter graphiquement un passager.
			\subsection{Contrôle utilisateur}
				Le jeu se joue entièrement a la souris et les interactions de l'utilisateur et comme expliqué dans les cas d'utilisation (voir \ref{useCases}) une fois en jeux il y plusieurs types d'interaction: le contrôle du temps a l'aide de boutons, le choix des bonus lorsqu'il apparaissent et le déplacement d'éléments du jeux.
				\p{Contrôle du temps}
					L'interface graphique contiendra un slider pour régler la vitesse du jeu, un bouton lecture et un bouton pause. A la modification de la vitesse de jeu ou la mise en pause / reprise le \jclass{ViewManager} envoie un event et le \jclass{GameManager} réagit en conséquence pour modifier le temps.
				\p{Choix des bonus}
					Pour le choix d'un bonus le \jclass{GameManager} appel une fonction du \jclass{ViewManager}. Le jeux est en pause le temps que le joueur choisisse un bonus, la fonction peut donc être bloquante. Au cas ou nous aurions besoin de continuer a exécuter des actions dans le thread du \jclass{GameManager}, nous réaliserons une fonction non bloquante qui retourne un \jclass{Futur}.
				\p{Déplacement d'éléments}
					Pour le déplacement des éléments nous avons décidé d'utiliser des états a la façon d'une state machine visibles sur la figure \ref{fig:ModificationStatesClassDiagram}. Le \jclass{ViewManager} aura une référence sur un \jclass{ModificationState}, au clic de la souris en fonction de l'objet pointé on l'assignera au l'état qui correspond (\jclass{MovingTrainState} si c'était un train\ldots) que l'objet soit sur la carte ou dans l'inventaire. On appel aussi la \jfunc{init} pour initialiser l'état (faire apparaitre le train sous la souris\ldots) et instancier les objets graphiques temporaire qui vont permettre une visualisation de la modification par l'utilisateur. Puis tout le long du drag n drop la fonction \jfunc{update} sera appelée pour actualiser ces objets temporaires en fonction (déplacer le train, tracer la ligne jusqu’à la souris\ldots). Au relâchement de la souris la fonction \jfunc{apply} est appelée pour que les objets temporaires soit supprimés, qu'un event soit envoyé et l'action validée par la logique qui modifiera la vue en conséquence (ajouter un train a une ligne\ldots).
					\begin{figure}[h!]
						\centering
						\includegraphics[width=\textwidth]{figures/ModificationStatesClassDiagram.png}
						\caption{Diagramme de classes: Modification states}
						\label{fig:ModificationStatesClassDiagram}
					\end{figure}
					TODO: Explication state en fonction de la souris
		\section{Liaison modèle -- vue}
			\begin{figure}[h!]
				\centering
				\includegraphics[width=\textwidth]{figures/ModelViewLinkClassDiagram}
				\caption{Diagramme de classes: Liaison modèle -- vue}
				\label{fig:ModelViewLinkClassDiagram}
			\end{figure}
			\p{Choix}
				Nous avons décidés pour pouvoir faire la communication du modèle vers la view de faire une communication par interface. Cette solution permet de faire une séparation entre le modèle et la vue et permet une certaine indépendance avec l'implémentation de la vue.
			\p{Fonctionnement}
				Comme on peux le voir avec le diagramme UML \ref{fig:ModelViewLinkClassDiagram}, les Trains et les stations vont avoir une référence respectivement sur une TrainView et une StationView. Ces deux interfaces sont implémenté dans le package view. Ainsi le modèle va interagir avec la vue grâce à ces interfaces. De même pour les autres classes comme SubSection, Inventory et GameMap.
		\section{Liaison vue -- modèle}
			\subsection{Communication par event}
				\p{Choix}
					Nous avons décider que la communication entre la vue et le modèle se ferait par event de façon a ce que la vue n'ait pas de référence sur les éléments du modèle. De cette façon on évite les problème de référencement circulaire qui en Java peuvent empêcher le \texttt{grabage collector} de libérer la mémoire. De plus cela accentue la séparation entre la vue et le modèle.
				\p{Fonctionnement}
					Le principe des events est que certains objets sont des \jclass{EventListener} (implémentent l'interface en Java), c'est a dire qu'il possède une fonction a appeler pour les notifier d'un event, cette fonction est souvent nommée \jfunc{onEvent} et elle contient les actions a effectuer lors de la réception d'un event. Tout ceci utilise des template sur les types des \jclass{Event} qui sont des extensions d'une base class \jclass{Event}. En java on utilisera les \texttt{Generics}.
			\subsection{EventDispatcher}
				\p{}
					Nous avons décidé d'utiliser d'utiliser un \texttt{EventDispatcher} pour l'envoi de nos events afin d'éviter le stockage de liste d'\jclass{EventListener} dans toutes nos classes qui envoient des events. Ce dernier a déjà été codé avant le projet, voir figure \ref{fig:EventDispatcherClassDiagram}. Il utilise des \jclass{WeakReference} et n'est donc pas a prendre en compte dans la gestion de la mémoire. De plus il est thread safe.
					\begin{figure}[h!]
						\centering
						\includegraphics[width=\textwidth]{figures/EventDispatcherClassDiagram}
						\caption{Diagramme de classes: EventDispatcher}
						\label{fig:EventDispatcherClassDiagram}
					\end{figure}
				\p{Fonctionnement}
					L'\jclass{EventDispatcher} est un singleton, il peut être utilisé de n'importe ou avec \jfunc{getInstance}. Les méthodes \jfunc{addListener} et \jfunc{removeListener} permettent de s'enregistrer ou dé-enregistrer en tant que \jclass{EventListener} pour un certain type d'\jclass{Event} passé en paramètre. Pour cela il faut implémenter l'interface \jinterface{EventListener}. Depuis \textit{Java 8} il est aussi possible de passer en paramètre une fonction lambda.
			\subsection{Utilisation concrète}
				\p{}
					La figure \ref{fig:ViewModelLinkClassDiagram} représente la liaison entre la vue et le modèle avec les event qui notifient des modification sur certains éléments du jeux a titre d'exemple. Différent types d'events seront crée pour chaque action de l'utilisateur mais la conception de la vue n'étant pas encore définitive et dépendante de \textit{JavaFx} nous n'avons pas encore décidé d'une représentation des données a envoyer dans les events (ex: description de la nouvelle position d'une ligne qui a été modifié).
					\begin{figure}[h!]
						\centering
						\includegraphics[width=\textwidth]{figures/ViewModelLinkClassDiagram}
						\caption{Diagramme de classes: Liaison vue -- modèle}
						\label{fig:ViewModelLinkClassDiagram}
					\end{figure}
				\p{}
					Concrètement et comme visible sur la figure \ref{fig:ViewModelLinkClassDiagram}, le \jclass{GameManager} possèdes des \jclass{EventListener} qui correspondent a chaque type d'event envoyé par le \jclass{ViewManager}, ces \jclass{EventListener} feront appel aux méthodes \jfunc{onEventXXX} du \jclass{GameManager}. La réceptions des events dans le modèle se fait donc par le \jclass{GameManager} qui modifie le contexte en conséquence. Du coté de la vue, sa conception n'étant pas encore définitive et dépendante de \textit{JavaFx}, il se pourrait que les events ne soient pas tous envoyé par le \jclass{ViewManager} mais qu'il soient envoyé par les éléments directement concerné (par exemple le \jclass{TrainView} pour notifier de son déplacement).

	\chapter{Solutions particulières}
		\section{Gestion du temps}
			\subsection{TimeManager}
				Pour résoudre le problème de la gestion du temps (lecture, pause, changement de vitesse) dans le jeux nous avons décidé de créer un \jclass{TimeManager}, cette classe sera un \textit{singleton} qui possèdera son propre thread. Le \jclass{TimeManager} aura une variable qui représente le temps écoulé depuis son démarrage. Il sera possible d'obtenir se temp en secondes (pour l'affichage dans la vue) ou en millisecondes (pour le modèle). La ou l'utilisation du \jclass{TimeManager} devient intéressant plutôt que d'utiliser le temps système c'est que sa vitesse d'écoulement du temps sera réglable. Sa variable de temps augmentera donc plus ou moins vite en fonction de la vitesse d'écoulement du temps précisé au \jclass{TimeManager}.
			\subsection{Temps réel}
				Le moteur du jeu, la boucle principale (déja abordée a la section \ref{gameLoop}) sera dans un thread géré par le \jclass{GameManager} et tournera a une vitesse fixe pour maintenir une fluidité. Pour les stations et bonus, a chaque tour de boucle on regarde le timecode de la prochaine apparition et on le compare au timecode actuel du \jclass{TimeManager}, si celui-ci est supérieur a celui de l'apparition on applique cette apparition. Pour les trains, il y aura un nombre fixe d'appel par seconde du jeu a leur fonction \jfunc{live}, secondes du \jclass{TimeManager} donc. Ainsi le nombre d'appel par secondes réelles (la vitesse du jeu) dépend de l'écoulement du temps du \jclass{TimeManager}, si celui-ci est en pause la fonction \jfunc{live} des trains n'est pas appelée et ceux ci ne se déplacent donc plus. De même le timecode d'apparition des stations et bonus n'est pas atteint (le temps n'avance pas), le jeu est donc bien en pause.
			\subsection{Contrôle du temps}
				La liaison entre le \jclass{ViewManager}, le \jclass{GameManager} et le \jclass{TimeManager} est visible sur la figure \ref{fig:TimeManagerLinkClassDiagram}. Le \jclass{ViewManager} lors de l'utilisation des boutons de contrôle du temps utilise les fonction du \jclass{TimeManager} pour régler le temps en fonction des modifications de l'utilisateur. Le \jclass{GameManager} lui lit le temps écoulé dans sa boucle de jeux pour effectuer ou non des actions en fonction du temps écoulé. De plus lors de la modification de la vitesse de temps, sa mise en pause ou sa reprise le \jclass{TimeManager} envoie des events pour notifier de ces changements. Ces events sont écoutés par le \jclass{GameManager} qui pourra arrêter sa boucle de jeu pour un \jclass{PauseEvent} et la relancer pour un \jclass{StartEvent} pour ne pas tourner inutilement par exemple (a voir a l'implémentation).
				\begin{figure}[h!]
					\centering
					\includegraphics[width=\textwidth]{figures/TimeManagerLinkClassDiagram.png}
					\caption{Diagramme de classes: Liaison au TimeManager}
					\label{fig:TimeManagerLinkClassDiagram}
				\end{figure}
		\section{Description des cartes}
			\p{problème}
				Les cartes de MiniMetro sont plus qu'une simple description de zone puisqu'elles sont entièrement scriptées, les bonus qui apparaitrons, le moment ou ils apparaitrons, les apparitions de stations, leur forme, position\ldots Sont identiques a chaque partie sur la carte.
			\p{Scripts}
				\begin{figure}[h!]
					\centering
					\includegraphics[width=\textwidth]{figures/ScriptsClassDiagram}
					\caption{Diagramme de classes: Scripts}
					\label{fig:ScriptsClassDiagram}
				\end{figure}
				Notre solution, visible sur la figure \ref{fig:ScriptsClassDiagram} a été de crée des classes de description que nous avons nommées scripts. A début d'une partie est créé le \jclass{GameManager}, on passe a ce dernier en paramètre de constructeur un \jclass{MapScript} qui contient toute les informations nécessaire au déroulement de la partie.
			\p{Utilisation}
				La boucle de gameplay principale qui gère principalement les trains s'occupera a chaque tour de boucle de regarder si le timecode du prochain évènement a été dépassé, si c'est le cas il agira en fonction de l'évènement.
			\p{Apparition d'une station}
				Dans le cas ou le timecode d'apparition de la prochaine station a été atteint, le \jclass{GameManager} instanciera une nouvelle \jclass{Station} avec les informations du \jclass{StationScript} tel que la position. Il utilisera la fonction \jfunc{createStationView} du \jclass{ViewManager} en passant en paramètre le type de la station pour obtenir une vue avec le skin associé au type de la station, le \jclass{StationView} retourné sera passé a la \jclass{Station}.
			\p{Choix d'un bonus}
				Les bonus dans Minimétro étant toujours des éléments a ajouté a l'inventaire (train, ligne\ldots), choisir un bonus revient juste a choisir un élément a ajouter a son inventaire. Dans le cas ou le timecode de la sélection du / des prochain bonus est dépassé, le \jclass{GameManager} utilisera les fonction (que nous n'avons pas encore définies) du \jclass{ViewManager} pour demander a l'utilisateur de choisir entre les différent bonus décrit dans le \jclass{ElementChoiceScript}. En fonction du choix de l'utilisateur le \jclass{GameManager} sélectionnera les scripts correspondants et suivra la même procédure que pour les \jclass{Station}. Il instanciera les éléments en fonction du script, leur associera une vue et les ajoutera a l'inventaire. L'énumération \jclass{ElementType} permet de sécuriser les cast.
	%\theupmdockeywords
	%\makebackcover
\end{document}
